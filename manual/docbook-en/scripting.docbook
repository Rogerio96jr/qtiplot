<?xml version="1.0" encoding="UTF-8"?>

<title>Mathematical Expressions and Scripting</title>

  <para>Starting with version 0.8.7, QtiPlot supports different interpreters
  for evaluating mathematical expressions and for executing scripts.</para>

  <sect1 id="sec-muParser">
    <title>muParser</title>

    <para>The constants _e=e=E and _pi=pi=PI=Pi are defined, as well as the
    following operators and functions.</para>

    <table frame="sides" pgwide="1" tocentry="1">
      <title>Supported Mathematical Operators</title>

      <tgroup cols="2">
        <colspec align="left" colname="name" colwidth="1*" />

        <colspec align="justify" colname="description" colwidth="10*" />

        <thead>
          <row>
            <entry>Name</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>+</entry>

            <entry>Addition</entry>
          </row>

          <row>
            <entry>-</entry>

            <entry>Substraction</entry>
          </row>

          <row>
            <entry>*</entry>

            <entry>Multiplication</entry>
          </row>

          <row>
            <entry>/</entry>

            <entry>Division</entry>
          </row>

          <row>
            <entry>^</entry>

            <entry>Exponentiation (raise a to the power of b)</entry>
          </row>

          <row>
            <entry>and</entry>

            <entry>logical and (returns 0 or 1)</entry>
          </row>

          <row>
            <entry>or</entry>

            <entry>logical or (returns 0 or 1)</entry>
          </row>

          <row>
            <entry>xor</entry>

            <entry>logical exclusive or (returns 0 or 1)</entry>
          </row>

          <row>
            <entry>&lt;</entry>

            <entry>less then (returns 0 or 1)</entry>
          </row>

          <row>
            <entry>&lt;=</entry>

            <entry>less then or equal (returns 0 or 1)</entry>
          </row>

          <row>
            <entry>==</entry>

            <entry>equal (returns 0 or 1)</entry>
          </row>

          <row>
            <entry>&gt;=</entry>

            <entry>greater then or equal (returns 0 or 1)</entry>
          </row>

          <row>
            <entry>&gt;</entry>

            <entry>greater then (returns 0 or 1)</entry>
          </row>

          <row>
            <entry>!=</entry>

            <entry>not equal (returns 0 or 1)</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

      <table frame="sides" pgwide="1" tocentry="1">
        <title>Mathematical Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="name" colwidth="1*" />

          <colspec align="justify" colname="description" colwidth="10*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>abs(x)</entry>

              <entry>absolute value of x</entry>
            </row>

            <row>
              <entry>acos(x)</entry>

              <entry>inverse cosinus</entry>
            </row>

            <row>
              <entry>acosh(x)</entry>

              <entry>inverse hyperbolic cosinus</entry>
            </row>

            <row>
              <entry>asin(x)</entry>

              <entry>inverse sinus</entry>
            </row>

            <row>
              <entry>asinh(x)</entry>

              <entry>inverse hyperbolic sinus</entry>
            </row>

            <row>
              <entry>atan(x)</entry>

              <entry>inverse tangent</entry>
            </row>

            <row>
              <entry>atanh(x)</entry>

              <entry>inverse hyperbolic tangent</entry>
            </row>

            <row>
              <entry>avg(x1,x2,x3,...)</entry>

              <entry>average value, this command accept a list of arguments
              separated by commas</entry>
            </row>

            <row>
              <entry>bessel_j0(x)</entry>

              <entry>Regular cylindrical Bessel function of zeroth order,
              J<subscript>0</subscript>(x).</entry>
            </row>

            <row>
              <entry>bessel_j1(x)</entry>

              <entry>Regular cylindrical Bessel function of first order,
              J<subscript>1</subscript>(x).</entry>
            </row>

            <row>
              <entry>bessel_jn(x,n)</entry>

              <entry>Regular cylindrical Bessel function of
              n<superscript>th</superscript> order,
              J<subscript>n</subscript>(x).</entry>
            </row>

            <row>
              <entry>bessel_y0(x)</entry>

              <entry>Irregular cylindrical Bessel function of zeroth order,
              Y<subscript>0</subscript>(x) for x&gt;0.</entry>
            </row>

            <row>
              <entry>bessel_y1(x)</entry>

              <entry>Irregular cylindrical Bessel function of first order,
              Y<subscript>1</subscript>(x) for x&gt;0.</entry>
            </row>

            <row>
              <entry>bessel_yn(x,n)</entry>

              <entry>Irregular cylindrical Bessel function of
              n<superscript>th</superscript> order,
              Y<subscript>n</subscript>(x) for x&gt;0.</entry>
            </row>

            <row>
              <entry>beta (a,b)</entry>

              <entry>Computes the Beta Function, B(a,b) =
              Gamma(a)*Gamma(b)/Gamma(a+b) for a &gt; 0 and b &gt; 0.</entry>
            </row>

            <row>
              <entry>cos(x)</entry>

              <entry>cosinus of x</entry>
            </row>

            <row>
              <entry>cosh(x)</entry>

              <entry>hyperbolic cosinus of x</entry>
            </row>

            <row>
              <entry>erf(x)</entry>

              <entry>error function of x</entry>
            </row>

            <row>
              <entry>erfc(x)</entry>

              <entry>Complementary error function erfc(x) = 1 -
              erf(x).</entry>
            </row>

            <row>
              <entry>erfz(x)</entry>

              <entry>The Gaussian probability density function Z(x).</entry>
            </row>

            <row>
              <entry>erfq(x)</entry>

              <entry>The upper tail of the Gaussian probability function
              Q(x).</entry>
            </row>

            <row>
              <entry>exp(x)</entry>

              <entry>Exponential function: e raised to the power of x.</entry>
            </row>

            <row>
              <entry>gamma(x)</entry>

              <entry>Computes the Gamma function, subject to x not being a
              negative integer</entry>
            </row>

            <row>
              <entry>gammaln(x)</entry>

              <entry>Computes the logarithm of the Gamma function, subject to
              x not a being negative integer. For x&lt;0, log(|Gamma(x)|) is
              returned.</entry>
            </row>

            <row>
              <entry>hazard(x)</entry>

              <entry>Computes the hazard function for the normal distribution
              h(x) = erfz(x)/erfq(x).</entry>
            </row>

            <row>
              <entry>ln(x)</entry>

              <entry>natural logarythm of x</entry>
            </row>

            <row>
              <entry>log(x)</entry>

              <entry>decimal logarythm of x</entry>
            </row>

            <row>
              <entry>log2(x)</entry>

              <entry>base 2 logarythm of x</entry>
            </row>

            <row>
              <entry>min(x1,x2,x3,...)</entry>

              <entry>Minimum of the list of arguments</entry>
            </row>

            <row>
              <entry>max(x1,x2,x3,...)</entry>

              <entry>Maximum of the list of arguments</entry>
            </row>

            <row>
              <entry>rint(x)</entry>

              <entry>Round to nearest integer.</entry>
            </row>

            <row>
              <entry>sign(x)</entry>

              <entry>Sign function: -1 if x&lt;0; 1 if x&gt;0.</entry>
            </row>

            <row>
              <entry>sin(x)</entry>

              <entry>sinus of x</entry>
            </row>

            <row>
              <entry>sinh(x)</entry>

              <entry>hyperblic sinus of x</entry>
            </row>

            <row>
              <entry>sqrt(x)</entry>

              <entry>square root of x</entry>
            </row>

            <row>
              <entry>tan(x)</entry>

              <entry>tangent of x</entry>
            </row>

            <row>
              <entry>tanh(x)</entry>

              <entry>hyperbolic tangent of x</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table frame="sides" pgwide="1" tocentry="1">
        <title>Non-Mathematical Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="name" colwidth="1*" />

          <colspec align="justify" colname="description" colwidth="10*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>cell(a,b)</entry>

				  <entry>In the contex of a matrix, returns the value at row a and column b.
					  In the context of a table, returns the value at column a and row b (remember that tables use column logic).
					  Everywhere else, this function is undefined.
				  </entry>
            </row>

            <row>
              <entry>col(c)</entry>

				  <entry>Only works in the context of a table.
					  Returns the value at column c and row i (the current row) in the context table.
					  c can either be the column's number, or its name in doublequotes.
				  </entry>
            </row>

            <row>
              <entry>if(e1,e2,e3)</entry>

              <entry>if e1 is true, e2 is executed else e3 is
              executed.</entry>
            </row>

            <row>
              <entry>tablecol(t,c)</entry>

				  <entry>Only works in the context of a table.
					  Returns the value at column c and row i (the current row) in the table t.
					  t is the table's name in doublequotes, c is either the column's number or its name in doublequotes.
				  </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
  </sect1>

  <sect1 id="Python">
    <title>Python</title>

    <para>This module provides bindings to the <ulink
    url="http://www.python.org">Python</ulink> programming language. Basic
    usage in the context of QtiPlot will be discussed below, but for more
    in-depth information on the language itself, please refer to its excellent
    <ulink url="http://www.python.org/doc">documentation</ulink>.</para>

    <sect2 id="Python-init">
      <title>The Initialization File</title>

      <para>This file allows you to customize the Python environment, import
      modules and define functions and classes that will be available in all
      of your projects. The default initialization file shipped with QtiPlot
      imports Python's <link linkend="Python-functions">standard math
      functions</link> as well as special functions from <ulink
      url="http://www.scipy.org">SciPy</ulink> (if available). Also, it
      creates some handy shortcuts, like
      <userinput>table("table1")</userinput> for
      <userinput>qti.app.table("table1")</userinput>.</para>

      <para>When activating Python support, QtiPlot searches the following
      places, executing the first file it can find:</para>

      <orderedlist>
        <listitem>
          <para>~/.qtiplotrc.py[c]</para>
        </listitem>

        <listitem>
          <para>/etc/qtiplotrc.py[c]</para>
        </listitem>

        <listitem>
          <para>./qtiplotrc.py[c]</para>
        </listitem>
      </orderedlist>

      <para>Files ending in .pyc are compiled versions of the .py source files
      and therefore load a bit faster. The compiled version will be used if
      the source file is older or nonexistent. Otherwise, QtiPlot will try to
      compile the source file (if you've got write permissions for the output
      file).</para>
    </sect2>

    <sect2>
      <title>Python Basics</title>

      <para>Mathematical expressions work largely as expected. However,
      there's one caveat, especially when switching from muParser (which has
      been used exclusively in previous versions of QtiPlot):
      <userinput>a^b</userinput> does not mean "raise a to the power of b" but
      rather "bitwise exclusive or of a and b"; Python's power operator is **.
      Thus: <screen width="40">
<userinput>2^3 # read: 10 xor 11 = 01</userinput>
<computeroutput>#&gt; 1</computeroutput>
<userinput>2**3</userinput>
<computeroutput>#&gt; 8</computeroutput>
</screen></para>

      <para>One thing you have to know when working with Python is that
      indentation is very important. It is used for grouping (most other
      languages use either braces or keywords like
      <userinput>do...end</userinput> for this). For example, <programlisting
      width="40">
x=23
for i in (1,4,5):
	x=i**2
	print(x)
	</programlisting> will do what you would expect: it prints out the numbers 1, 16 and
      25; each on a line of its own. Deleting just a bit of space will change
      the functionality of your program: <programlisting>
x=23
for i in (1,4,5):
	x=i**2
print(x)
	</programlisting> will print out only one number - no, not 23, but rather 25. This
      example was designed to also teach you something about variable scoping:
      There are no block-local variables in Python.</para>

      <para>There are two different variable scopes to be aware of: local and
      global variables. Unless specified otherwise, variables are local to the
      context in which they were defined. Thus, the variable
      <varname>x</varname> can have three different values in, say, two
      different Note windows and a column formula. Global variables on the
      other hand can be accessed from everywhere within your project. A
      variable <varname>x</varname> is declared global by executing the
      statement <userinput>global x</userinput>. You have to do this before
      assigning a value to <varname>x</varname>, but you have to do it only
      once within the project (no need to "import" the variable before using
      it). Note that there is a slight twist to these rules when you <link
      linkend="Python-def">define your own functions</link>.</para>
    </sect2>

    <sect2 id="Python-def">
      <title>Defining Functions and Control Flow</title>

      <para>The basic syntax for defining a function (for use within one
      particular note, for example) is <programlisting>
def answer():
	return 42
	</programlisting> If you want your function to be accessible from the rest of your
      project, you have to declare it global before the definition: <programlisting
      width="40">
global answer
def answer():
	return 42
	</programlisting> You can add your own function to QtiPlot's function list. We'll
      also provide a documentation string that will show up, for example, in
      the "set column values" dialog: <programlisting>
global answer
def answer():
	"Return the answer to the ultimate question about life, the universe and everything."
	return 42
qti.mathFunctions["answer"] = answer
	</programlisting> If you want to remove a function from the list, do: <programlisting
      width="40">
del qti.mathFunctions["answer"]
	</programlisting></para>

      <para>Note that functions have their own local scope. That means that if
      you enter a function definition in a Note, you will not be able to
      access (neither reading nor writing) Note-local variables from within
      the function. However, you can access global variables as usual.</para>

      <para>If-then-else decisions are entered as follows: <programlisting>
if x&gt;23:
	print(x)
else:
	print("The value is too small.")
	</programlisting></para>

      <para>You can do loops, too: <programlisting>
for i in range(1, 11):
	print(i)
	</programlisting> This will print out the numbers between 1 and 10 inclusively (the
      upper limit does not belong to the range, while the lower limit
      does).</para>
    </sect2>

    <sect2 id="Python-functions">
      <title>Mathematical Functions</title>

      <para>Python comes with some basic mathematical functions that are
      automatically imported (if you use the <link
      linkend="Python-init">initialization file</link> shipped with QtiPlot).
      Along with them, the constants e (Euler's number) and pi (the one and
      only) are defined.</para>

      <table frame="sides" pgwide="1" tocentry="1">
        <title>Supported Mathematical Functions</title>

        <tgroup cols="2">
          <colspec align="left" colname="name" colwidth="1*" />

          <colspec align="justify" colname="description" colwidth="10*" />

          <thead>
            <row>
              <entry>Name</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>acos(x)</entry>

              <entry>inverse cosinus</entry>
            </row>

            <row>
              <entry>asin(x)</entry>

              <entry>inverse sinus</entry>
            </row>

            <row>
              <entry>atan(x)</entry>

              <entry>inverse tangent</entry>
            </row>

            <row>
              <entry>atan2(y,x)</entry>

              <entry>equivalent to atan(y/x), but more efficient</entry>
            </row>

            <row>
              <entry>ceil(x)</entry>

              <entry>ceiling; smallest integer greater or equal to x</entry>
            </row>

            <row>
              <entry>cos(x)</entry>

              <entry>cosinus of x</entry>
            </row>

            <row>
              <entry>cosh(x)</entry>

              <entry>hyperbolic cosinus of x</entry>
            </row>

            <row>
              <entry>degrees(x)</entry>

              <entry>convert angle from radians to degrees</entry>
            </row>

            <row>
              <entry>exp(x)</entry>

              <entry>Exponential function: e raised to the power of x.</entry>
            </row>

            <row>
              <entry>fabs(x)</entry>

              <entry>absolute value of x</entry>
            </row>

            <row>
              <entry>floor(x)</entry>

              <entry>largest integer smaller or equal to x</entry>
            </row>

            <row>
              <entry>fmod(x,y)</entry>

              <entry>remainder of integer division x/y</entry>
            </row>

            <row>
              <entry>frexp(x)</entry>

              <entry>Returns the tuple (mantissa,exponent) such that
              x=mantissa*(2**exponent) where exponent is an integer and 0.5
              &lt;=abs(m)&lt;1.0</entry>
            </row>

            <row>
              <entry>hypot(x,y)</entry>

              <entry>equivalent to sqrt(x*x+y*y)</entry>
            </row>

            <row>
              <entry>ldexp(x,y)</entry>

              <entry>equivalent to x*(2**y)</entry>
            </row>

            <row>
              <entry>log(x)</entry>

              <entry>natural (base e) logarythm of x</entry>
            </row>

            <row>
              <entry>log10(x)</entry>

              <entry>decimal (base 10) logarythm of x</entry>
            </row>

            <row>
              <entry>modf(x)</entry>

              <entry>return fractional and integer part of x as a
              tuple</entry>
            </row>

            <row>
              <entry>pow(x,y)</entry>

              <entry>x to the power of y; equivalent to x**y</entry>
            </row>

            <row>
              <entry>radians(x)</entry>

              <entry>convert angle from degrees to radians</entry>
            </row>

            <row>
              <entry>sin(x)</entry>

              <entry>sinus of x</entry>
            </row>

            <row>
              <entry>sinh(x)</entry>

              <entry>hyperblic sinus of x</entry>
            </row>

            <row>
              <entry>sqrt(x)</entry>

              <entry>square root of x</entry>
            </row>

            <row>
              <entry>tan(x)</entry>

              <entry>tangent of x</entry>
            </row>

            <row>
              <entry>tanh(x)</entry>

              <entry>hyperbolic tangent of x</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2 id="Python-API">
      <title>Accessing QtiPlot's objects from Python</title>

      <para>We will assume that you are using the <link
      linkend="Python-init">initialization file</link> shipped with
      QtiPlot. Accessing the objects in your project is straight-forward,
        <programlisting>
t = table("Table1")
m = matrix("Matrix1")
g = graph("Graph1")
n = note("Notes1")
	  </programlisting> as is creating new objects: <programlisting>
# create an empty table named "tony" with 5 rows and 2 columns:
t = newTable("tony", 5, 2)
# use defaults
t = newTable()
# create an empty matrix named "gina" with 42 rows and 23 columns:
m = newMatrix("gina", 42, 23)
# use defaults
m = newMatrix()
# create an empty graph window
g = newGraph()
# create a graph window named "test" with two layers disposed on a 2 rows x 1 column grid
g = newGraph("test", 2, 2, 1)
# create an empty note named "momo"
n = note("momo")
# use defaults
n = note()
</programlisting></para>
<para>Every piece of code is executed in the context of an
object which you can access via the <varname>self</varname> variable. For example,
entering <userinput>self.cell("t",i)</userinput> as a column formula is equivalent to the convenience
function <userinput>col("t")</userinput>.</para>

Once you have established contact with a MDI window, you can modify some of it's properties, like the name, the window label, the geometry, etc..
For example, here's how to rename a window, change it's label and the way they are displayed in the window title bar, the so called caption policy:
<programlisting>
t = table("Table1")
setWindowName(t, "toto")
t.setWindowLabel("tutu")
t.setCaptionPolicy(MDIWindow.Both)
</programlisting>
The caption policy can have one of the following values:
	<orderedlist>
        <listitem>
          Name <para>the window caption is determined by the window name</para>
        </listitem>
        <listitem>
          Label<para>the caption is detemined by the window label</para>
        </listitem>
        <listitem>
          Both<para>caption = "name - label"</para>
        </listitem>
      </orderedlist>

For a fast editing process, you can create template files from existing tables, matrices or plots. The templates can be used later on in order to create customized windows very easily:
<programlisting>
saveAsTemplate(graph("Graph1"), "my_plot.qpt")
g = openTemplate("my_plot.qpt")
</programlisting>

Also, you can easily clone a MDI window:
<programlisting>
g1 = clone(graph("Graph1"))
</programlisting>
</sect2>

<sect2 id="Python-Folders">
<title>Project Folders</title>
Storing your data tables/matrices and your plots in folders can be very convenient and helpful
when you're analysing loads of data files in the same project.
New objects will always be added to the active folder. You can get a pointer to it via:
<programlisting>
f = activeFolder()
</programlisting>
The functions table, matrix, graph and note will start searching in the active folder and, failing this,
will continue with a depth-first recursive search of the project's root folder, given by:
<programlisting>
f = rootFolder()
</programlisting>
In order to access subfolders and windows, there are the following functions:
<programlisting>
f2 = f.folders()[number]
f2 = f.folder(name, caseSensitive=True, partialMatch=False)
t = f.table(name, recursive=False)
m = f.matrix(name, recursive=False)
g = f.graph(name, recursive=False)
n = f.note(name, recursive=False)
</programlisting>
If you supply True for the recursive argument, a depth-first recursive search of all subfolders will
be performed and the first match returned.
<para>New folders can be created using:</para>
<programlisting>
newFolder = addFolder("New Folder", parentFolder = 0)
</programlisting>
If the <varname>parentFolder</varname> is not specified, the new folder will be added as a subfolder of the project's
root folder. When you create a new folder via a Python script, it doesn't automatically become the active folder
of the project. You have to set this programatically, using:
<programlisting>
changeFolder(newFolder, bool force=False)
</programlisting>
Folders can be deleted using:
<programlisting>
deleteFolder(folder)
</programlisting>
You can save a folder as a project file, and of course, you can also save the whole project:
<programlisting>
saveFolder(folder, "new_file.qti", compress=False)
saveProjectAs("new_file_2.qti", compress=False)
</programlisting>
If <varname>compress</varname> is set to True, the project file will be archived to the .gz format, using zlib.
<para>Also, you can load a QtiPlot or an Origin project file into a new folder.
The new folder will have the base name of the project file and will be added as a subfolder
to the <varname>parentFolder</varname> or to the current folder if no parent folder is specified.</para>
<programlisting>
newFolder = appendProject("projectName", parentFolder = 0)
</programlisting>
If you don't want to be asked for confirmation when a table/matrix is renamed during this operation,
or when deleting a folder via a Python script, you must change your preferences
concerning prompting of warning messages, using the <link linkend="fig-preferences-dialog-2">Preferences dialog ("Confirmations" tab)</link>.
</sect2>

<sect2 id="Python-Tables">
<title>Working with Tables</title>
We'll assume that you have assigned some table to the variable
<varname>t</varname>. You can access its numeric cell values with
<programlisting>
t.cell(col, row)
# and
t.setCell(col, row, value)
</programlisting>
Whenever you have to specify a column, you can use either the
column name (as a string) or the consecutive column number (starting
with 1). Row numbers also start with 1, just as they are displayed. If
you want to work with arbitrary texts or the textual representations
of numeric values, you can use:
<programlisting>
t.text(col, row)
# and
t.setText(col, row, string)
</programlisting>
The number of columns and rows is accessed via:
<programlisting>
t.numRows()
t.numCols()
t.setNumRows(number)
t.setNumCols(number)
</programlisting>
You can delete a range of rows using:
<programlisting>
t.deleteRows(startRowNumber, endRowNumber)
</programlisting>
Column names can be read and written with:
<programlisting>
t.colName(number)
t.setColName(col, newName, enumerateRight=False)
</programlisting>
If <varname>enumerateRight</varname> is set to True, all the table columns starting from index
<varname>col</varname> will have their names modified to a combination of the
<varname>newName</varname> and a numerical increasing index. If this parameter is not specified,
by default it is set to False.

<para>You can change the plot role of a table column (abscissae, ordinates, error bars, etc...) using:</para>
<programlisting>
t.setColumnRole(col, role)
</programlisting>
where <varname>role</varname> specifies the desired column role:
<variablelist spacing="compact">
            <varlistentry>
              <term>0.</term>
              <listitem>
                <para>Table.None</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>1.</term>
              <listitem>
                <para>Table.X</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>2.</term>
              <listitem>
                <para>Table.Y</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>3.</term>
              <listitem>
                <para>Table.Z</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>4.</term>
              <listitem>
                <para>Table.xErr</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>5.</term>
              <listitem>
                <para>Table.yErr</para>
              </listitem>
            </varlistentry>
			<varlistentry>
              <term>6.</term>
              <listitem>
                <para>Table.Label</para>
              </listitem>
            </varlistentry>
</variablelist>

<para>You can normalize a single column or all columns in a table:</para>
<programlisting>
t.normalize(col)
t.normalize()
</programlisting>
Sort a single or all columns:
<programlisting>
t.sortColumn(col, order = 0);
t.sort(type = 0, order = 0, leadingColumnName)
</programlisting>

Import values from <varname>file</varname>, using <varname>sep</varname> as separator char, ignoring
<varname>ignoreLines</varname> lines at the head of the file and all lines starting with a <varname>comment</varname> string.
<programlisting>
t.importASCII(file, sep="\t",ignoreLines=0,renameCols=False,stripSpaces=True,simplifySpace=False, 
importComments=False,comment="#",readOnly=False,importAs=Table.Overwrite,endLine=0,maxRows=-1)
</programlisting>

As you see from the above list of import options, you have the possibility to set the new columns as read-only.
This will prevent the imported data from beeing modified. You have the possibility to remove this protection
at any time, by using:
<programlisting>
t.setReadOnlyColumn(col, False)
</programlisting>

<para>The <varname>importAs</varname> flag can have the following values: 
<variablelist spacing="compact">
            <varlistentry>
              <term>0.</term>
              <listitem>
                <para>Table.NewColumns: data values are added as new columns.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>1.</term>
              <listitem>
                <para>Table.NewRows: data values are added as new rows.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>2.</term>
              <listitem>
                <para>Table.Overwrite: all existing values are overwritten (default value).</para>
              </listitem>
            </varlistentry>
</variablelist></para>

<para>The <varname>endLine</varname> flag specifies the end line character convention used in the ascii file.
Possible values are: 0 for line feed (LF), which is the default value, 
1 for carriage return + line feed (CRLF) and 2 for carriage return only (usually on Mac computers).</para>

<para>The last parameter <varname>maxRows</varname> allows you to specify a maximum number of imported 
lines. Negative values mean that all data lines must be imported.</para>

<para>You can export values from a table to an ASCII <varname>file</varname>, using
<varname>sep</varname> as separator chararacter. The <varname>ColumnLabels</varname> option
allows you to export or ignore the column labels, <varname>ColumnComments</varname> does the same for the comments
displayed in the table header and the <varname>SelectionOnly</varname> option makes
possible to export only the selected cells of the table.</para>
<programlisting>
t.exportASCII(file,sep="\t",ignore=0,ColumnLabels=False,ColumnComments=False,SelectionOnly=False)
</programlisting>
 Other settings that you can modify are the text displayed as a comment in the header of a column
or the expression used to calculate the column values. Please beware that changing the command doesn't automatically
update the values of the column!
<programlisting>
t.setComment(col, newComment)
t.setCommand(col, newExpression)
</programlisting>

After having changed some table values from a script, you will likely want to update dependent Graphs:
<programlisting>
t.notifyChanges()
</programlisting>

You can also modify the width of a column (in pixels) or hide/show table columns:
<programlisting>
t.setColumnWidth(col, width)
t.hideColumn(col, True)
</programlisting>


As a simple example, let's set some column values without using the dialog.
<programlisting>
t = table("table1")
for i in range(1, t.numRows()+1):
	t.setCell(1, i, i**2)
t.notifyChanges()
</programlisting>
</sect2>

<sect2 id="Python-Matrix">
<title>Working with Matrices</title>
Matrix objects have a dual view mode: either as images or as data tables.
Assuming that you have assigned some matrix to the variable
<varname>m</varname>, you can change it's display mode via the following function:
<programlisting>
m.setViewType(Matrix.TableView)
m.setViewType(Matrix.ImageView)
</programlisting>

If a matrix is viewed as an image, you have the choice to display it
either as gray scale or using a predefined color map:
<programlisting>
m.setGrayScale()
m.setRainbowColorMap()
</programlisting>

Accessing cell values is very similar to Table,
but since Matrix doesn't use column logic, row arguments are specified
before columns and obviously you can't use column name.
<programlisting>
m.cell(row, col)
m.setCell(row, col, value)
m.text(row, col)
m.setText(row, col, string)
</programlisting>

An alternative solution to assign values to a Matrix, would be to define a formula and to calculate the values using this formula, like in the following example:
<programlisting>
m.setFormula("x*y*sin(x*y)")
m.calculate()
</programlisting>

You can also specify a column/row range in the calculate() function, like this:
<programlisting>
m.calculate(startRow, endRow, startColumn, endColumn)
</programlisting>

Before setting the values in a matrix you might want to define the numeric precision,
that is the number of significant digits used for the computations:
<programlisting>
m.setNumericPrecision(prec)
</programlisting>
Also, like with tables, you can access the number of rows/columns in a matrix:
<programlisting>
rows = m.numRows()
columns = m.numCols()
</programlisting>

Matrix objects allow you to define a system of x/y coordinates that will be used when plotting color/contour maps or 3D height maps.
You can manipulate these coordinates using the following functions:
<programlisting>
xs = m.xStart()
xe = m.xEnd()
ys = m.yStart()
ye = m.yEnd()
m.setCoordinates(xs + 2.5, xe, ys - 1, ye + 1)
</programlisting>

The horizontal and vertical headers of a matrix can display either the x/y coordinates or
the column/row indexes:
<programlisting>
m.setHeaderViewType(Matrix.ColumnRow)
m.setHeaderViewType(Matrix.XY)
</programlisting>

There are several built-in transformations that you can apply to a matrix object.
You can transpose or invert a matrix and calculate its determinant, provided, of course, that
the conditions on the matrix dimensions, required by these operations, are matched:
<programlisting>
m.transpose()
m.invert()
d = m.determinant()
</programlisting>

Some other operations, very useful when working with images, like 90 degrees rotations and mirroring,
can also be performed. By default rotations are performed clockwise. For a counterclockwise rotation
you must set the <varname>clockwise</varname> parameter to <varname>False</varname>.
<programlisting>
m.flipVertically()
m.flipHorizontally()
m.rotate90(clockwise = True)
</programlisting>

Please note that sometimes, after a change in the matrix settings,
you need to use the following function in order to update the display:
<programlisting>
m.resetView()
</programlisting>

If you need to get data from a table, in order to use it in a matrix (or vice-versa), you can
avoid time consuming copy/paste operations and speed up the whole proces by simply converting
the table into a matrix:
<programlisting>
m = tableToMatrix(table("Table1"))
t = matrixToTable(m)
</programlisting>

Also, it's worth knowing that you can easily import image files to matrices, that can be
used afterwards for plotting (see the next section for more details about 2D plots):
<programlisting>
m1 = importImage("C:/poze/adi/PIC00074.jpg")
m2 = newMatrix()
m2.importImage("C:/poze/adi/PIC00075.jpg")
</programlisting>
The algorithm used to import the image returns a gray value between 0 and 255 from the (r, g, b) triplet
corresponding to each pixel. The gray value is calculated using the formula: (r * 11 + g * 16 + b * 5)/32

<para>For custom image analysis operations, you can get a copy of the matrix image view, as a QImage object, via:</para>
<programlisting>
image = m.image()
</programlisting>

You can export matrices to all raster image formats supported by Qt or to any of the following vectorial image format: 
EPS, PS, PDF or SVG using: 
<programlisting>
m.export(fileName)
</programlisting>

This is a shortcut function which uses some default parameters in order to generate the output image.
If you need more control over the export parameters you must use one of the following functions:
<programlisting>
m1.exportRasterImage(fileName, quality = 100)
m2.exportVector(fileName,resolution,color = true,keepAspect = true,pageSize = QPrinter::Custom)
</programlisting>

<para>You can also import an ASCII data <varname>file</varname>, using <varname>sep</varname> as separator characters, ignoring
<varname>ignore</varname> lines at the head of the file and all lines starting with a <varname>comment</varname> string:
</para>
<programlisting>
m.importASCII(file, sep="\t", ignore=0, stripSpaces=True, simplifySpace=False, comment="#", 
				importAs=Matrix.Overwrite, locale=QLocale(), endLine=0, maxRows=-1)
</programlisting>

<para>The <varname>importAs</varname> flag can have the following values: 
<variablelist spacing="compact">
            <varlistentry>
              <term>0.</term>
              <listitem>
                <para>Matrix.NewColumns: data values are added as new columns.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>1.</term>
              <listitem>
                <para>Matrix.NewRows: data values are added as new rows.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>2.</term>
              <listitem>
                <para>Matrix.Overwrite: all existing values are overwritten (default value).</para>
              </listitem>
            </varlistentry>
</variablelist>

The <varname>locale</varname> parameter can be used to specify the convention for decimal separators used in your ASCII file.</para>

<para>The <varname>endLine</varname> flag specifies the end line character convention used in the ascii file.
Possible values are: 0 for line feed (LF), which is the default value, 
1 for carriage return + line feed (CRLF) and 2 for carriage return only (usually on Mac computers).</para>

<para>The last parameter <varname>maxRows</varname> allows you to specify a maximum number of imported 
lines. Negative values mean that all data lines must be imported.</para>

<para>Also, you can export values from a matrix to an ASCII <varname>file</varname>, using
<varname>sep</varname> as separator chararacters. The <varname>SelectionOnly</varname> option makes
possible to export only the selected cells of the matrix.</para>
<programlisting>
m.exportASCII(file, sep="\t", SelectionOnly=False)
</programlisting>
</sect2>

<sect2 id = "Python-Plots2D">
<title>2D Plots</title>
As you have seen in the previous section, it is possible create 2D plots from matrices.
Here's how you can do it in practice:
<programlisting>
m = importImage("C:/poze/adi/PIC00074.jpg")
g1 = plot(m, Layer.ColorMap)
g2 = plot(m, Layer.Contour)
g3 = plot(m, Layer.GrayScale)
</programlisting>

If you want to create a new Graph window for some data in table Table1, you can use the plot command:
<programlisting>
t = table("Table1")
g = plot(t, column, type)
</programlisting>
<varname>type</varname> specifies the desired plot type and can be one of the following numbers or the equivalent reserved word:
	  <variablelist spacing="compact">
            <varlistentry>
              <term>0</term>

              <listitem>
                <para>Layer.Line</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>1</term>

              <listitem>
                <para>Layer.Scatter</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>2</term>

              <listitem>
                <para>Layer.LineSymbols</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>3</term>

              <listitem>
                <para>Layer.VerticalBars</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>4</term>

              <listitem>
                <para>Layer.Area</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>5</term>

              <listitem>
                <para>Layer.Pie</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>6</term>

              <listitem>
                <para>Layer.VerticalDropLines</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>7</term>

              <listitem>
                <para>Layer.Spline</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>8</term>

              <listitem>
                <para>Layer.HorizontalSteps</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>9</term>

              <listitem>
                <para>Layer.Histogram</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>10</term>

              <listitem>
                <para>Layer.HorizontalBars</para>
              </listitem>
            </varlistentry>

			 <varlistentry>
              <term>13</term>

              <listitem>
                <para>Layer.Box</para>
              </listitem>
            </varlistentry>

			<varlistentry>
              <term>15</term>

              <listitem>
                <para>Layer.VerticalSteps</para>
              </listitem>
            </varlistentry>
          </variablelist>

You can plot more than one column at once by giving a Python tuple (see the <ulink url="http://docs.python.org/tut">Python
Tutorial</ulink>) as an argument:
<programlisting>
g1 = plot(table("Table1"), (2,4,7), 2)
g2 = plot(table("Table1"), ("Table1_2","Table1_3"), Layer.LineSymbols)
</programlisting>

You can also create a vector plot by giving four columns in
a Python tuple as an argument and the plot type as Layer.VectXYXY (11) or Layer.VectXYAM (14),
depending on how you want to define the end point of your vectors: using (X, Y) coordinates or
(Angle, Magnitude) coordinates.
<programlisting>
g = plot(table("Table1"), (2,3,4,5), Layer.VectXYXY)
</programlisting>

If you want to add a curve to an existing Graph window, you have
to choose the destination layer. Usually,
<programlisting>
l = g.activeLayer()
</programlisting>
will do the trick, but you can also select a layer by its number:
<programlisting>
l = g.layer(num)
</programlisting>

<sect3 id="Python-Curves">
<title>Working with curves</title>
You can then add or remove curves to or from this layer:
<programlisting>
l.insertCurve(table, Xcolumn, Ycolumn, type=Layer.Scatter)
l.addCurve(table, column, type=Layer.Line, lineWidth = 1, symbolSize = 3, startRow = 0, endRow = -1)
l.addCurves(table, (2,4), type=Layer.Line, lineWidth = 1, symbolSize = 3, startRow = 0, endRow = -1)
l.removeCurve(curveName)
l.removeCurve(curveNumber)
l.deleteFitCurves()
</programlisting>
You can also add analytical function curves to a plot layer:
<programlisting>
l.addFunction("x*sin(x)", 0, 3*pi, points = 100);
l.addParametricFunction("cos(m)", "sin(m)", 0, 2*pi, points = 100, variableName = "m")
l.addPolarFunction("t", "t", 0, 2*pi, points = 100, variableName = "t")
</programlisting>
In case you need the number of curves on a layer, you can get it with <programlisting>
l.numCurves()
</programlisting>
</sect3>

<sect3 id="Python-Title">
<title>The plot title</title>
<programlisting>
l.setTitle("My beautiful plot")
l.setTitleFont(QtGui.QFont("Arial", 12))
l.setTitleColor(QtGui.QColor("red"))
l.setTitleAlignment(QtCore.Qt.AlignLeft)
</programlisting>
The alignment parameter can be any combination of the Qt alignment flags (see the
<ulink url="http://www.riverbankcomputing.com/Docs/PyQt4/html/qt.html#AlignmentFlag-enum">PyQt documentation</ulink>
for more details).
<para>If you want you can remove the plot title using:</para>
<programlisting>
l.removeTitle()
</programlisting>
</sect3>

<sect3 id="Python-Axes">
<title>Customizing the axes</title>
Layer axes can be shown/hidden using the following function:
<programlisting>
l.enableAxis(int axis, on = True)
</programlisting>
where <varname>axis</varname> can be any integer value between 0 and 3 or the equivalent reserved word:
	  <variablelist spacing="compact">
            <varlistentry>
              <term>0.</term>
              <listitem>
                <para>Layer.Left</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>1.</term>
              <listitem>
                <para>Layer.Right</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>2.</term>
              <listitem>
                <para>Layer.Bottom</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>3.</term>
              <listitem>
                <para>Layer.Top</para>
              </listitem>
            </varlistentry>
          </variablelist>

If an axis is enabled, you can fully customize it via a Python script.
For example you can set it's title:
<programlisting>
l.setAxisTitle(axis, "My axis title")
l.setAxisTitleFont(axis, QtGui.QFont("Arial", 11))
l.setAxisTitleColor(axis, QtGui.QColor("blue"))
l.setAxisTitleAlignment(axis, alignFlags)
</programlisting>
it's color and the font used for the tick labels:
<programlisting>
l.setAxisColor(axis, QtGui.QColor("green"))
l.setAxisFont(axis, QtGui.QFont("Arial", 10))
</programlisting>

The tick labels of an axis can be enabled or disabled, you can set their color and their rotation angle:
<programlisting>
l.enableAxisLabels(axis, on = True)
l.setAxisLabelsColor(axis, QtGui.QColor("black"))
l.setAxisLabelRotation(axis, angle)
</programlisting>
<varname>angle</varname> can be any integer value between -90 and 90 degrees.
A rotation angle can be set only for horizontal axes (Bottom and Top).
<para>The numerical format of the labels can be set using:</para>
<programlisting>
l.setAxisNumericFormat(axis, format, precision = 6, formula)
</programlisting>
where <varname>format</varname> can have the following values: <variablelist spacing="compact">
            <varlistentry>
              <term>0.</term>
              <listitem>
                <para>Automatic: the most compact numeric representation is chosen</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>1.</term>
              <listitem>
                <para>Decimal: numbers are displayed in floating point form</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>2.</term>
              <listitem>
                <para>Scientific: numbers are displayed using the exponential notation</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>3.</term>
              <listitem>
                <para>Superscripts: like Scientific, but the exponential part is displayed as a power of 10</para>
              </listitem>
            </varlistentry>
          </variablelist>
<varname>precision</varname> is the number of significant digits and
<varname>formula</varname> is a mathematical expression that can be used to link oposite scales. It's
argument must be <varname>x</varname> for horizontal axes and <varname>y</varname> for vertical axes.
For example, assuming that the bottom axis displays a range of wavelengths in nanometers and that the top
axis represents the equivalent energies in eV, with the help of the code bellow all the wavelengths
will be automatically converted to electron-volts and the result will be displayed in floating point form
with two significant digits after the decimal dot sign:
<programlisting>
l.setAxisNumericFormat(Layer.Top, 1, 2, "1239.8419/x")
</programlisting>

The axis ticks can be customized via the following functions:

<programlisting>
l.setTicksLength(minLength, majLength)
l.setAxisTicksLength(axis, majTicksType, minTicksType, minLength, majLength)
</programlisting>
where the <varname>majTicksType</varname> and <varname>minTicksType</varname> parameters specify the
desired orientation for the major and minor ticks, respectively:
<variablelist spacing="compact">
            <varlistentry>
              <term>0.</term>
              <listitem>
                <para>Layer.NoTicks</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>1.</term>
              <listitem>
                <para>Layer.Out: outward orientation for ticks, with respect to the plot canvas</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>2.</term>
              <listitem>
                <para>Layer.InOut: both inward and outward ticks</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>3.</term>
              <listitem>
                <para>Layer.In: inward ticks</para>
              </listitem>
            </varlistentry>
          </variablelist>
<varname>minLength</varname> specifies the length of the minor ticks, in pixels and
<varname>majLength</varname> the length of the major ticks.

<para>You can also customize the scales of the different axes using: <programlisting>
l.setScale(int axis, double start, double end, double step=0.0, int majorTicks=5, int minorTicks=5, int type=0, bool inverted=False);
</programlisting>
where <varname>type</varname> specifies the desired scale type: <variablelist spacing="compact">
            <varlistentry>
              <term>0.</term>
              <listitem>
                <para>Layer.Linear</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>1.</term>
              <listitem>
                <para>Layer.Log10</para>
              </listitem>
            </varlistentry>
          </variablelist>
and <varname>step</varname> defines the size of the interval between the major scale ticks. If not specified (default value is 0.0), the step size is calculated automatically.
The other flags should be self-explanatory.</para>

Defining a scale range for an axis doesn't automatically disable autoscaling.
This means that if a curve is added or removed from the layer, the axes will still automatically
adapt to the new data interval. This can be avoided by disabling the autoscaling mode, thus
making sure that your scale settings will always be taken into account:
<programlisting>
l.enableAutoscaling(False)
</programlisting>

If you want to rescale the plot layer so that all the data points are visible, you can use the following utility function:
<programlisting>
l.setAutoScale()
</programlisting>

The same <varname>setScale</varname> function above, with a longer list of arguments,
can be used to define an axis break region: 
<programlisting>
l.setScale(axis, start, end, step=0.0, majorTicks=5, minorTicks=5, type=0, inverted=False,
	left=-DBL_MAX, right=DBL_MAX, breakPosition=50, stepBeforeBreak=0.0, stepAfterBreak=0.0,
	minTicksBeforeBreak=4, minTicksAfterBreak=4, log10AfterBreak=False, breakWidth=4, breakDecoration=True);
</programlisting>
where <varname>left</varname> specifies the left limit of the break region,
<varname>right</varname> the right limit, 
<varname>breakPosition</varname> is the position of the break expressed as a percentage of the axis length and
<varname>breakWidth</varname> is the width of the break region in pixels.
The names of the other parameters should be self-explanatory.

<para>Finally, you can specify the width of all axes and enable/disable the drawing of their 
backbone line, using:</para>
<programlisting>
l.setAxesLinewidth(2)
l.drawAxesBackbones(True)
</programlisting>
</sect3>

<sect3 id="Python-Canvas">
<title>The canvas</title>
You can display a rectangular frame around the drawing area of the plot (the canvas) and
fill it with a background color, using:<programlisting>
l.setCanvasFrame(2, QtGui.QColor("red"))
l.setCanvasColor(QtGui.QColor("lightGrey"))
</programlisting>
Drawing the canvas frame and disabling the axes backbone lines
is the only possible solution for the issue of axes not touching themselves at their ends.
</sect3>

<sect3 id="Python-Frame">
<title>The layer frame</title>
You can display a rectangular frame around the whole layer and fill it with a background color,
using:<programlisting>
l.setFrame(2, QtGui.QColor("blue"))
l.setBackgroundColor(QtGui.QColor("grey"))
</programlisting>
The default spacing between the layer frame and the other layer elements (axes, title) can be changed via:
<programlisting>
l.setMargin(10)
</programlisting>
</sect3>

<sect3 id="Python-Grid-2D">
<title>Customizing the grid</title>

You can display the grid associated to a layer axis or the whole grid using:<programlisting>
l.showGrid(axis)
l.showGrid()
</programlisting>
This will display the grid with the default color, width and pen style settings.
If you need to change these settings, as well as to enable/disable certain grid lines,
you can use the following functions:<programlisting>
grid = l.grid()
grid.setMajPenX(QtGui.QPen(QtCore.Qt.red, 1))
grid.setMinPenX(QtGui.QPen(QtCore.Qt.yellow, 1, QtCore.Qt.DotLine))
grid.setMajPenY(QtGui.QPen(QtCore.Qt.green, 1))
grid.setMinPenY(QtGui.QPen(QtCore.Qt.blue, 1, QtCore.Qt.DashDotLine))
grid.enableXMax(True)
grid.enableXMin()
grid.enableYMax()
grid.enableYMin(False)
grid.enableZeroLineX(True)
grid.enableZeroLineY(False)
l.replot()
</programlisting>
All the grid functions containing an <varname>X</varname> refer to the vertical grid lineas, whereas the <varname>Y</varname> leter indicates the horizontal ones.
Also, the <varname>Maj</varname> word refers to the main grid lines and <varname>Min</varname> to the secondary grid.
</sect3>

<sect3 id="Python-Legends">
<title>The plot legend</title>
You can add a new legend to a plot using: <programlisting>
legend = l.newLegend()
#or
legend = l.newLegend("enter your text here")
</programlisting>

Once you have created a legend, it's very easy to customize it.
If you want to modify the text you can use:<programlisting>
l.setLegend("enter your text here")
#or
legend.setText("Enter your text here")
</programlisting>

All other properties of the legend: text color, background color, frame style, font and position of the top-left corner
can be modified via the following functions:<programlisting>
legend.setTextColor(QtGui.QColor("red"))
legend.setBackgroundColor(QtGui.QColor("yellow"))
legend.setFrameStyle(Legend.Shadow)
legend.setFont(QtGui.QFont("Arial", 14, QtGui.QFont.Bold, True))
# set top-left position using scale coordinates:
legend.setOriginCoord(200.5, 600.32) 
# or set top-left position using pixel coordinates:
legend.setOrigin(5, 10) 
l.replot()
</programlisting>

Other frame styles available for legends are: <varname>Legend.Line</varname>, which draws a rectangle around the text
and <varname>Legend.None</varname> (no frame at all). There are also functions allowing you to remove
the default legend or to add an automatically built time stamp:
<programlisting>
l.removeLegend()
l.addTimeStamp()
</programlisting>
</sect3>

<sect3 id="Python-Arrows">
<title>Adding arrows/lines to a plot layer</title>
<programlisting>
arrow = ArrowMarker()
arrow.setStart(10.5, 12.5)
arrow.setEnd(200, 400.51)
arrow.setStyle(QtCore.Qt.DashLine)
arrow.setColor(QtGui.QColor("red"))
arrow.setWidth(1)
arrow.drawStartArrow(False)
arrow.drawEndArrow(True)
arrow.setHeadLength(7)
arrow.setHeadAngle(35)
arrow.fillArrowHead(True)

l = newGraph().activeLayer()
l.addArrow(arrow)
</programlisting>
</sect3>

<sect3 id="Python-Images">
<title>Adding images to a layer</title>
<programlisting>
l = newGraph().activeLayer()
image = l.addImage("C:/poze/adi/PIC00074.jpg")
image.setCoordinates(200, 800, 800, 200)
l.replot()
</programlisting>

The <varname>setCoordinates</varname> function above can be used to set the geometry of the image using
scale coordinates. If you need to specify the image geometry in pixel coordinates, independently of
the plot axes values, you may use the following functions:
<programlisting>
image.setOrigin(x, y)
image.setSize(width, height)
image.setRect(x, y, width, height)
l.replot()
</programlisting>
</sect3>

<sect3 id="Python-Antialiasing">
<title>Antialiasing</title>
Antialiasing can be enabled/disabled for the drawing of the curves and other layer
objects, but it is a very resources consuming feature:<programlisting>
l.setAntialiasing(True, bool update = True)
</programlisting>
</sect3>

<sect3 id="Python-Resizing">
<title>Resize events</title>
The default behaviour of 2D plot layers, with respect to the resizing of the graph window
is to adapt their size and the sizes of the fonts used for the various texts, to the new size
of the plot window. You can override this behaviour and make the layers ignore any resize events coming from the
parent window: <programlisting>
l.setIgnoreResize(True)
l.setAutoscaleFonts(False)
</programlisting>
</sect3>

<sect3 id="Python-Exporting-2DPlots">
<title>Exporting plots/layers to different image formats</title>
Layers and whole Graphs can be printed and exported from within Python.
The fastest way to export a plot/layer is the following: <programlisting>
l.export(fileName)
</programlisting>

This function uses some default parameters
for the properties of the image. If you need more control over the exported images you can use one
of the following specialized functions:<programlisting>
l.exportVector(fileName, resolution = 96, color = True, keepAspect = True, pageSize = QtGui.QPrinter.Custom);
l.exportImage(filename, quality=100, transparent=False)</programlisting>

<para>The function <varname>exportVector</varname> can export the plot/layer to the following vector formats:
.eps, .ps, .pdf. By setting the <varname>keepAspect</varname> variable to True (the default), the
width/height ratio of the plot will be maintained in the exported image. This has the drawback that sometimes
there are some visible white margins around the plot. In order to avoid the white borders you can set this option to False
and in this case the plot will be scaled to fill the whole area of the <varname>pageSize</varname>,
thus modifing its aspect. By default QtiPlot chooses a <varname>pageSize</varname> which fits best the
real size of the plot, but you can specify a standard output page size, like: QtGui.QPrinter.A4, QtGui.QPrinter.A5, etc...</para>

<para>The function <varname>exportImage</varname> can be used if you need to export to
one of the Qt supported bitmap image formats (.bmp, .png, .jpg, etc...). The <varname>transparent</varname>
option can only be used in conjunction with the file formats supporting transprency: .png and .tif (.tiff).
The <varname>quality</varname> parameter influences the size of the output file. The higher this value (maximum is 100),
the higher the qualitity of the image, but the larger the size of the resulting files.</para>

<para>All the export functions rely on the file name suffix in order to choose the image format.</para>
</sect3></sect2>

<sect2 id="Python-MultiLayer">
      <title>Arranging Layers</title>
When you are working with many layers in a 2D plot window, setting the layout of these layers manually can
be a very tedious task. With the help of a simple Python script you can make this task very easy and
automatically manage the layout of the plot window.
For example, here's how you can create a two rows by two columns matrix of layers,
each plot layer having a canvas size (the drawing area) of 400 pixels wide and 300 pixels in height:
<programlisting>
g = newGraph("Test", 4, 2, 2)
g.setLayerCanvasSize(400, 300)
g.arrangeLayers(False, True)
</programlisting>

The <varname>arrangeLayers()</varname> function takes two parameters. The first one specifies
if the layers should be arranged automatically, using a best-layout algorithm, or if the
numbers of rows and columns is fixed by the user. If the value of the second parameter is
<varname>True</varname>, the size of the canvas is fixed by the user and the plot window
will be enlarged or shrinked, according to the user settings. Otherwise the size of the plot
window will be kept and the canvas area of each layer will be automatically adapted to fit this size.
Here's how you can modify the graph created in the previous example, in order to display a row of three
layers, while keeping the size of the plot window unchanged:
<programlisting>
g.setNumLayers(3)
g.setRows(1)
g.setCols(3)
g.arrangeLayers(False, False)
</programlisting>

By default, the space betwee two neighbouring layers as well as the distance between the layers
and the borders of the plot window is set to five pixels. You can change the spacing between the
layers and the margins using the following functions:
<programlisting>
g.setSpacing (x, y)
g.setMargins (left, right, top, bottom)
</programlisting>

Another aspect of the layout management is the alignement of the layers. There are three alignement
flags that you can use for the horizontal alignement (HCenter, Left, Right) and another three for
the vertical alignement (VCenter, Top, Bottom) of the layers. The following code line
aligns the layers with the right edge of the window and centers them vertically in the available space:
<programlisting>
g.setAlignement(Graph.Right, Graph.VCenter)
</programlisting>

All the examples above suppose that the layers are aranged on a grid, but of course you can add layers
at any position in the plot window. In the examples bellow the x, y coordinates, in pixels,
refer to the position of the top-left corner of the layer.
The origin of the coordinates system coincides with the top-left corner of the plot window, the y
coordinate increasing towards the bottom of the window. If the width and height of the layer are not specified
they will be set to the default values:
<programlisting>
g = newGraph()
l1 = g.addLayer()
l2 = g.addLayer(10, 20, 200, 200)
l3 = g.addLayer(215, 20)
</programlisting>

As you have already seen, in a plot window the active layer is, by default, the last layer added
to the plot, but you can change it programatically:
<programlisting>
l = g.layer(num)
g.setActiveLayer(l)
</programlisting>

In case you need to perform a repetitive task on all the layers in a plot window, you need to use a for loop
and of course you need to know the number of layers existant on the plot. Here's a small example showing how to
custom the titles of all the layers in the plot window:
<programlisting>
g = graph("Graph1")
layers = g.numLayers()
for i in range (1, layers+1):
	l = g.layer(i)
	l.setTitle("Layer"+QtCore.QString.number(i))
	l.setTitleColor(QtGui.QColor("red"))
	l.setTitleFont(QtGui.QFont("Arial", 14, QtGui.QFont.Bold, True))
	l.setTitleAlignment(QtCore.Qt.AlignLeft)
</programlisting>

Finally, sometimes it might be useful to be able to swap two layers. This can be done with the help of the
following function:
<programlisting>
g.swapLayers(layerNum1, layerNum2)
</programlisting>
</sect2>

<sect2 id="Python-Plots3D">
<title>3D Plots</title>
<sect3>
<title>Creating a 3D plot</title>
You can plot 3D analytical functions or parametric surfaces.
For the 3D functions, the only parameters allowed are <varname>x</varname> for the the abscissae values and <varname>y</varname> for the ordinates:
<programlisting>
g = plot3D("sin(x*y)", -10.0, 10.0, -10.0, 10.0, -2.0, 2.0)
</programlisting>
For the parametric surfaces the only parameters allowed are the latitude and the longitude: <varname>u</varname> and <varname>v</varname>. Here's, for example,
how you can plot a sphere:
<programlisting>
g = plot3D("cos(u)*cos(v)", "sin(u)*cos(v)", "sin(v)", -3.14, 3.14, -2, 2)
</programlisting>
You can also create 3D height maps using data from matrices and, of course, you can plot table columns:
<programlisting>
g = plot3D(matrix("Matrix1"), style = 5)
g = plot3D(table("Table1"), "3", style)
</programlisting>
In the case of 3D plots created from matrix data sources the <varname>style</varname> parameter can take
any integer value from 1 to 5, with the following signification:
<variablelist spacing="compact">
            <varlistentry>
              <term>1.</term>
              <listitem>
                <para>Wireframe style</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>2.</term>
              <listitem>
                <para>Hidden Line style</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>3.</term>
              <listitem>
                <para>Color filled polygons without edges</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>4.</term>
              <listitem>
                <para>Color filled polygons with separately colored edges</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>5.</term>
              <listitem>
                <para>Scattered points (the default style)</para>
              </listitem>
            </varlistentry>
          </variablelist>

For 3D plots created from tables the <varname>style</varname> parameter can take
any integer value from 0 to 3 or the equivalent style values from the follwing list:

<variablelist spacing="compact">
            <varlistentry>
              <term>0.</term>
              <listitem>
                <para>Graph3D.Scatter</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>1.</term>
              <listitem>
                <para>Graph3D.Trajectory</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>2.</term>
              <listitem>
                <para>Graph3D.Bars</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>3.</term>
              <listitem>
                <para>Graph3D.Ribbon</para>
              </listitem>
            </varlistentry>
          </variablelist>

An alternative method to create a 3D plot is to create an empty plot window and to assign a data source to it.
As you have already seen a data source can be an analytical function, a matrix or a table.
For large data sets you can increase the drawing speed by reducing the number of points
taken into account. The lower the resolution parameter, the higher the number of points used:
for an integer value of 1, all the data points are drawn.
<programlisting>
g = newPlot3D()
g.setTitle("My 3D Plot", QtGui.QColor("blue"), QtGui.QFont("Arial",14))
g.setResolution(2)
g.setFunction("sin(x*y)", -10.0, 10.0, -10.0, 10.0, -2.0, 2.0)
#or
g.setData(table("Table1"), "3")
#or
g.setMatrix(matrix("Matrix1"))
</programlisting>

Once a plot is created, you can modify the scales and set the data range to display, using, for example:
<programlisting>
g.setScales(-1.0, 1.0, -10.0, 11.0, -2.0, 3.0)
</programlisting>
</sect3>

<sect3 id="Python-3D-View">
<title>Customizing the view</title>
When a new 3D plot is created, the scene view parameters are set to default values.
Of course, QtiPlot provides functions to customize each aspect of the view.
For example, you can set rotation angles, in degrees, around the X, Y and Z axes, respectively, using:
<programlisting>
g.setRotation(45, 15, 35)
</programlisting>

The following function allows you to shift the plot along the world X, Y and Z axes, respectively:
<programlisting>
g.setShift(3.0, 7.0, -4.0)
</programlisting>

You can also zoom in/out the entire plot as a whole, or you can zoom along a particular axis:
<programlisting>
g.setZoom(10)
g.setScale(0.1, 0.05, 0.3)
</programlisting>

Also, you can automatically detect the zoom values that fit best with the size of the plot window:
<programlisting>
g.findBestLayout()
</programlisting>

You can enable/disable the perspective view mode or animate the view using:
<programlisting>
g.setOrthogonal(False)
g.animate(True)
</programlisting>
</sect3>

<sect3 id="Python-3D-Style">
<title>Plot Styles</title>
The style of the 3D plot can be set using the following functions:
<programlisting>
g.setPolygonStyle()
g.setFilledMeshStyle()
g.showLegend(True)
g.setHiddenLineStyle()
g.setWireframeStyle()
g.setAntialiasing(True)
g.setMeshLineWidth(0.7)
</programlisting>

For scatter plots using points you can specify the radius of the points and their shape:
circles if <varname>smooth</varname> is True, rectangles otherwise.
<programlisting>
g.setDotOptions(10, smooth = True)
g.setDotStyle()
</programlisting>

Other symbols available for scatter plots are: bars
<programlisting>
g.setBarRadius(0.01)
g.setBarStyle()
</programlisting>
cones
<programlisting>
g.setConeOptions(radius, quality)
g.setConeStyle()
</programlisting>
and crosses (surrounded by a box frame, if <varname>boxed</varname> is set to True):
<programlisting>
g.setCrossOptions(radius, width, smooth, boxed)
g.setCrossStyle()
</programlisting>
</sect3>

<sect3 id="Python-3D-Projection">
<title>The 2D Projection</title>
By default the floor projection of the 3D surface plot is disabled. You can enable a full 2D projection
or only display the isolines using the following functions:
<programlisting>
g.showFloorProjection()
g.showFloorIsolines()
g.setEmptyFloor()
</programlisting>
</sect3>

<sect3 id="Python-3D-Coordinates">
<title>Customizing the Coordinates System</title>
The coordinates system around the surface plot can be customized to display all the twelve axes,
only three of them or none, respectively, with the help of the following funcions:
<programlisting>
g.setBoxed()
g.setFramed()
g.setNoAxes()
</programlisting>

If the axes are enabled, you can set their legends and the distance between the legend and the axes via:
<programlisting>
g.setXAxisLabel("X axis legend")
g.setYAxisLabel("Y axis legend")
g.setZAxisLabel("Z axis legend")
g.setLabelsDistance(30)
</programlisting>

Also, you can fix the length of the major and minor ticks of an axis:
<programlisting>
g.setXAxisTickLength(2.5, 1.5)
g.setYAxisTickLength(2.5, 1.5)
g.setZAxisTickLength(2.5, 1.5)
</programlisting>
</sect3>

<sect3 id="Python-3D-Grid">
<title>Grid</title>
If the coordinate system is displayed, you can also display a grid around the surface plot.
Each side of the grid can be shown/hidden:
<programlisting>
g.setLeftGrid(True)
g.setRightGrid()
g.setCeilGrid()
g.setFloorGrid()
g.setFrontGrid()
g.setBackGrid(False)
</programlisting>
</sect3>

<sect3 id="Python-3D-Colors">
<title>Customizing the Plot Colors</title>
The color map of the plot can be defined using two colors, one for the maximum data values and
one for the minimum data values, or you can use more complex color maps defined in .map files.
A .map file consists of a of 255 lines, each line defining a color coded as RGB values.
A set of predefined color map files can be downloaded from QtiPlot web site, in the "Miscelanous"
section.
<programlisting>
g.setDataColors(QtGui.QColor("red"), QtGui.QColor("orange"))
#or
g.setDataColorMap(fileName)
g.update()
</programlisting>

The colors of all the other plot elements can be customized as shown bellow. Don't forget to
update the plot in order to display the new colors:
<programlisting>
g.setMeshColor(QtGui.QColor("blue"))
g.setAxesColor(QtGui.QColor("green"))
g.setNumbersColor(QtGui.QColor("black"))
g.setLabelsColor(QtGui.QColor("darkRed"))
g.setBackgroundColor(QtGui.QColor("lightYellow"))
g.setGridColor(QtGui.QColor("grey"))
g.setDataColors(QtGui.QColor("red"), QtGui.QColor("orange"))
g.setOpacity(0.75)
g.update()
</programlisting>
</sect3>

<sect3 id="Python-3D-Export">
<title>Exporting</title>
Finally here's how you can export the 3D plot to an image file:
<programlisting>
g.export(fileName)
g.exportVector(fileName)
g.exportImage(fileName, int quality = 100, bool transparent = False)
</programlisting>
</sect3>
</sect2>

<sect2 id="Python-DataAnalysis">
<title>Data Analysis</title>
<sect3 id="Python-GeneralFunctions">
<title>General Functions</title>
As you will see in the following subsections, the data analysis operations available
in QtiPlot are: convolution/deconvolution, correlation, differentiation, FFT, filtering,
smoothing, fitting and numerical integration of data sets.

Generally, you can declare/initialize an analysis operation using one of the following methods,
depending on the data source, which can be a 2D plot curve or a table:
<programlisting>
op = FFTFilter(graph("Graph1").activeLayer(), "Table1_2", 1.5, 3.9)
op = LinearFit(table("Table1"), "colX", "colY", 10, 100)
</programlisting>

In the first example the data source is a curve <emphasis>Table1_2</emphasis>, plotted
in the active layer of the graph <emphasis>Graph1</emphasis> and the abscissae range is
chosen between 1.5 and 3.9.
In the second example the data source is a table <emphasis>Table1</emphasis>.
The abscissae of the data set are stored in the column called <emphasis>colX</emphasis>
and the ordinates in the column <emphasis>colY</emphasis>. The data range is
chosen between the 10th row and the row with the index 100. If you don't specify the row range,
by default the whole table will be used.

Not all operations support curves as data sources, like for example:
convolution/deconvolution and correlation. For these operations only table columns can be used
as data sources for the moment.

<para>Once you have initialized an operation, you can still chage it's input data via
the following functions:</para>
<programlisting>
op.setDataFromCurve("Table1_energy", 10.5, 20.1, graph("Graph2").activeLayer())
op.setDataFromTable(table("Table1"), "colX", "colY", 10, 100)
</programlisting>

You don't have to specify a plot layer in the setDataFromCurve() function, if the analysis operation has
already been initialized by specifying a curve on an existing graph and you just want to treat another
curve from the same plot layer.

<para>Also, when performing analysis tasks via Python scripts, there are several utility functions that
can be called for all operations. For example you can disable any graphical output from an operation
or you can redirect the output to the plot layer of your choice: </para>
<programlisting>
op.enableGraphicsDisplay(False)
op.enableGraphicsDisplay(True, graph("Graph2").activeLayer())
</programlisting>

Let's assume that you need to perform a specific operation <varname>op</varname>,
which analyses your data and at the end, displays a result curve.
For this kind of operations, you can customize the number of points in the resulting curve
and its color:
<programlisting>
op.setOutputPoints(int)
op.setColor(int)
op.setColor("green")
</programlisting>
Colors can be specified by their names or as integer values, from 0 to 23,
each integer corresponding to a predefined color: 0 - "black", 1 - "red", 2 - "green", 3 - "blue",
4 - "cyan", 5 - "magenta", 6 - "yellow", 7 - "darkYellow", 8 - "navy", 9 - "purple", etc ...

<para>Most of the time, a new table is also created as a result of a data analysis operation.
This table stores the data displayed by the result curve and is hidden by default,
but you can interact with it via the following function:
<programlisting>
t = op.resultTable()
</programlisting></para>

After the initialization of an analysis operation, which consists of setting the data source,
the data range and some other properties, like color, number of points, etc..., you can execute
it via a call to its run() function:
<programlisting>
op.run()
</programlisting>
For data fitting operations, there's an alias for the run() function which is: fit().
</sect3>

<sect3 id="Python-Correlation">
<title>Correlation, Convolution/Deconvolution</title>
Assuming you have a table named "Table1", here's how you can calculate the convolution of two of it's columns,
"Table1_B" and "Table1_C":
<programlisting>
conv = Convolution(table("Table1"),  "B", "C")
conv.setColor("green")
conv.run()
</programlisting>
The deconvolution and the correlation of two data sets can be done using a similar synthax:
<programlisting>
dec = Deconvolution(table("Table1"),  "B", "C")
dec.run()

cor = Correlation(table("Table1"),  "B", "C", 10, 200)
cor.setColor("green")
cor.run()
</programlisting>
</sect3>

<sect3 id="Python-Differentiation">
<title>Differentiation</title>
Assuming you have a Graph named "Graph1" with a curve entitled
"Table1_2" (on its active layer), here's how you can differentiate this curve within a defined x interval,
[2,10] in this case:
<programlisting>
diff = Differentiation(graph("Graph1").activeLayer(), "Table1_2", 2, 10)
diff.run()
</programlisting>
The result of these code sequence would be a new plot window displaying the derivative of the initial curve.
The numerical derivative is calculated using a five terms formula.
</sect3>

<sect3 id="Python-FFT">
<title>FFT</title>
Assuming you have a graph named "Graph1" with a curve entitled
"Table1_2" (on its active layer), having a periodicity of 0.1 in the time domain,
a FFT will allow you to extract it's characteristic frequencies.
The results will be stored in a hidden table named "FFT1".

<programlisting>
fft = FFT(graph("Graph1").activeLayer(), "Table1_2")
fft.normalizeAmplitudes(False)
fft.shiftFrequencies(False)
fft.setSampling(0.1)
fft.run()
</programlisting>

By default the calculated amplitudes are normalized
and the corresponding frequencies are shifted in order to obtain a centered x-scale.
If we want to recover the initial curve with the help of the inverse transformation, we
mustn't modify the amplitudes and the frequencies. Also the sampling parameter must be set to
the inverse of the time period, that is 10. Here's how we can perform the inverse FFT, using the "FFT1" table,
in order to recover the original curve:

<programlisting>
ifft = FFT(table("FFT1"), "Real", "Imaginary")
ifft.setInverseFFT()
ifft.normalizeAmplitudes(False)
ifft.shiftFrequencies(False)
ifft.setSampling(10)
ifft.run()
</programlisting>
</sect3>

<sect3 id="Python-Filtering">
<title>FFT Filters</title>
In this section, it will be assumed that you have a signal (data set "Table1_2") displayed in a graph ("Graph1", on its active layer).
This signal has a power spectrum with high and low frequencies.
You can filter some of these frequencies according to your needs, using a FFTFilter.
Here's how you can cut all the frequencies lower than 1 Hz:
<programlisting>
filter = FFTFilter(graph("Graph1").activeLayer(), "Table1_2", FFTFilter.HighPass)
filter.setCutoff(1)
filter.run()
</programlisting>

Here's how you can cut all the frequencies lower than 1.5 Hz and higher than 3.5 Hz.
In the following example the continuous component of the signal is also removed:
<programlisting>
filter.setFilterType(FFTFilter.BandPass)
filter.enableOffset(False)
filter.setBand(1.5, 3.5)
filter.run()
</programlisting>

Other types of FFT filters available in QtiPlot are: low pass (<varname>FFTFilter.LowPass</varname>)
and band block (<varname>FFTFilter.BandBlock</varname>).
</sect3>
<sect3 id="Python-Fitting">
<title>Fitting</title>
        Assuming you have a graph named "Graph1" with a curve entitled
        "Table1_2" (on its active layer), a minimal Fit example would be:
        <programlisting>
f = GaussFit(graph("Graph1").activeLayer(), "Table1_2")
f.guessInitialValues()
f.fit()
	  </programlisting> This creates a new GaussFit object on the curve, lets it guess
        the start parameters and does the fit. The following fit types are
        supported: <itemizedlist>
            <listitem>
              <para>LinearFit(layer, curve)</para>
            </listitem>

            <listitem>
              <para>PolynomialFit(layer, curve, degree=2, legend=False)</para>
            </listitem>

            <listitem>
              <para>ExponentialFit(layer, curve, growth=False)</para>
            </listitem>

            <listitem>
              <para>TwoExpFit(layer, curve)</para>
            </listitem>

            <listitem>
              <para>ThreeExpFit(layer, curve)</para>
            </listitem>

            <listitem>
              <para>GaussFit(layer, curve)</para>
            </listitem>

            <listitem>
              <para>GaussAmpFit(layer, curve)</para>
            </listitem>
            <listitem>
              <para>LorentzFit(layer, curve)</para>
            </listitem>
			<listitem>
              <para>LogisticFit(layer, curve)</para>
            </listitem>
            <listitem>
              <para>SigmoidalFit(layer, curve)</para>
            </listitem>
            <listitem>
              <para>NonLinearFit(layer, curve)</para>
		    <programlisting>
f = NonLinearFit(layer, curve)
f.setParameters(name1, ...)
f.setFormula(formula_string)
f.save(fileName)
		    </programlisting>
            </listitem>
            <listitem>
		    <para>PluginFit(layer, curve)</para>
		    <programlisting>
f = PluginFit(layer, curve)
f.load(pluginName)
		    </programlisting>
            </listitem>
          </itemizedlist> For each of these, you can optionally restrict the X
        range that will be used for the fit, like in <programlisting>
f = LinearFit(graph("Graph1").activeLayer(), "Table1_2", 2, 7)
f.fit()
	  </programlisting>

You can also restrict the search range for any of the fit parameters:
<programlisting>
f = NonLinearFit(graph("Graph1").activeLayer(), "Table1_2")
f.setParameters("a0", "a1", "a2")
f.setFormula("a0+a1*x+a2*x*x")
f.setParameterRange(parameterIndex, start, end)
</programlisting>

All the settings of a non-linear fit can be saved to an XML file and restored later one, using this file,
for a faster editing process. Here's for example how you can save the above fit function:
<programlisting>
f.save("/fit_models/poly_fit.txt")
</programlisting>
and how you can use this file during another fitting session, later on:
<programlisting>
f = NonLinearFit(graph("Graph1").activeLayer(), "Table1_2")
f.load("/fit_models/poly_fit.txt")
f.fit()
</programlisting>

        <para>After creating the Fit object and before calling its fit()
        method, you can set a number of parameters that influence the fit:
        <programlisting>
f.setDataFromTable(table("Table4"), "w", "energy", 10, 200) <lineannotation>change data source</lineannotation>
f.setDataFromCurve(curve)			<lineannotation>change data source</lineannotation>
f.setDataFromCurve(curve, graph)		<lineannotation>change data source</lineannotation>
f.setDataFromCurve(curve, from, to)		<lineannotation>change data source</lineannotation>
f.setDataFromCurve(curve, from, to, graph)	<lineannotation>change data source</lineannotation>
f.setInterval(from, to)				<lineannotation>change data range</lineannotation>
f.setInitialValue(number, value)
f.setInitialValues(value1, ...)
f.guessInitialValues()
f.setAlgorithm(algo) # algo = Fit.ScaledLevenbergMarquardt, Fit.UnscaledLevenbergMarquardt, Fit.NelderMeadSimplex
f.setWeightingData(method, colname) # method = Fit.NoWeighting, Fit.Instrumental, Fit.Statistical, Fit.Dataset
f.setTolerance(tolerance)
f.setOutputPrecision(precision)
f.setMaximumIterations(number)
f.scaleErrors(yes = True)
f.setColor("green")			<lineannotation>change the color of the result fit curve to green (default color is red)</lineannotation>
	  </programlisting></para>

After you've called fit(), you have a number of possibilities
for extracting the results: <programlisting>
f.results()
f.errors()
f.chiSquare()
f.rSquare()
f.dataSize()
f.numParameters()
f.parametersTable("params")
f.covarianceMatrix("cov")
</programlisting>

It is important to know that QtiPlot can generate an analytical formula
for the resulting fit curve or a normal plot curve with data stored in a hidden table.
You can choose either of these two output options, before calling the fit() instruction, using:
<programlisting>
f.generateFunction(True, points=100)
</programlisting>

If the first parameter of the above function is set to True,
QtiPlot will generate an analytical function curve. If the <varname>points</varname> parameter
is not specified, by default the function will be estimated over 100 points.
You can get the analytical formula of the fit curve via a call to resultFormula():
<programlisting>
formula = f.resultFormula()
print(formula)
</programlisting>

If the first parameter of generateFunction() is set to False, QtiPlot will create a hidden data
table contining the same number of points as the data set/curve to be fitted (same abscissae).
You can interact with this table and extract the data points of the result fit curve using:
<programlisting>
t = f.resultTable()
</programlisting>
</sect3>

<sect3 id="Python-Integration">
<title>Integration</title>
With the same assumptions as above, here's how you can integrate a curve within a given interval:
<programlisting>
integral = Integration(graph("Graph1").activeLayer(), "Table1_2", 2, 10)
integral.setMethodOrder(4)
integral.setTolerance(1e-4)
integral.setMaximumIterations(100)
integral.run()
result = integral.area()
</programlisting>
The method order parameter can be any integer value between 1 (Trapezoidal rule, the default value) and 5.
The code integrates the curve using an iterative algorithm. The tolerance determines the termination criteria for the solver.
Because, sometimes we ask for too much accuracy, setting a maximum number of iterations makes sure
that the solver will not enter an infinite loop, which could freeze the application.

<para>As you can see from the above example, the numerical value of the integral can be obtained
via the <varname>area()</varname> function.</para>
</sect3>

<sect3 id="Python-Interpolation">
<title>Interpolation</title>
The interpolation is used to generate a new data curve with a high number of points
from an existing data set. Here's an example:
<programlisting>
interpolation = Interpolation(graph("Graph1").activeLayer(), "Table1_2", 2, 10, Interpolation.Linear)
interpolation.setOutputPoints(10000)
interpolation.setColor("green")
interpolation.run()
</programlisting>
The simplest interpolation method is the linear method. There are two other methods available:
<varname>Interpolation.Akima</varname> and <varname>Interpolation.Cubic</varname>.
You can choose the interpolation method using:
<programlisting>
interpolation.setMethod(Interpolation.Akima)
</programlisting>
</sect3>

<sect3 id="Python-Smooth">
<title>Smoothing</title>
Assuming you have a graph named "Graph1" with an irregular curve entitled
"Table1_2" (on its active layer). You can smooth this curve using a SmoothFilter:
<programlisting>
smooth = SmoothFilter(graph("Graph1").activeLayer(), "Table1_2", SmoothFilter.Average)
smooth.setSmoothPoints(10)
smooth.run()
</programlisting>

The default smoothing method is the mowing window average. Other smoothing methods are the
<varname>SmoothFilter.FFT</varname> and <varname>SmoothFilter.SavitzkyGolay</varname>. Here's an example
of how to use this last method:
<programlisting>
smooth.setSmoothPoints(5,5)
smooth.setMethod(SmoothFilter.SavitzkyGolay)
smooth.setPolynomOrder(9)
smooth.run()
</programlisting>
</sect3>
</sect2>

<sect2 id="Python-QtDialogs">
<title>Using Qt's dialogs and classes</title>
Let's assume that you have a lot of ASCII data files to analyze.
Furthermore, let's suppose that these files were created
during several series of measurements, each measurement generating a set
of files identified by a certain string in the file name, like for example: "disper1".
In order to analyze these files, you need first of all to import them into tables.
The following code snippet shows how to automize this task using Qt dialogs and convenience classes:

<programlisting>
# Pop-up a file dialog allowing to chose the working folder:
dirPath = QtGui.QFileDialog.getExistingDirectory(qti.app, "Choose Working Folder", "/test/")

# Create a folder object using Qt's QDir class:
folder = QtCore.QDir(dirPath)

# Pop-up a text input dialog allowing to chose the file naming pattern:
namePattern = QtGui.QInputDialog.getText(qti.app, "Enter Pattern", "Text: ", QtGui.QLineEdit.Normal, "disper1")

# Get the list of file names in the working directory containing the above pattern:
fileNames = folder.entryList (QtCore.QStringList ("*_" + namePattern[0] + "*.dat"))

# Import each file into a new project table:
for i in range (0, lst.count()):
    t = newTable()
    t.importASCII(dirPath + fileNames[i], " ", 0, False, True, True)
</programlisting>

For a detailed description of all the dialogs and utility classes provided by Qt/PyQt
please take a look at the
<ulink url="http://www.riverbankcomputing.com/Docs/PyQt4/html/classes.html">PyQt documentation</ulink>.
</sect2>
</sect1>
